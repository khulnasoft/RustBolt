# Roadmap

The current document lists some important features that Rustbolt will support, some of which are already in progress, while others will be implemented in future versions of Rustbolt.

> Last updated: February 2025

## Rustbolt 1.x iteration

Rustbolt will release a minor version every 2-3 months, each containing significant new features and performance improvements.

See [Rustbolt blogs](/blog/index) to learn about the latest minor versions of Rustbolt.

## Wasm build

We plan to compile Rustbolt's Rust code into WebAssembly format, allowing Rustbolt to run in the browser.

You can see the current progress in this PR: [#9134](https://github.com/khulnasoft/rustbolt/pull/9134).

## Introduce Rstest

We are implementing **Rstest**, a testing framework based on Rustbolt. It can seamlessly integrate with Rustbolt's ecosystem and provide out-of-the-box testing capabilities.

We plan to release the first version of Rstest in the second half of 2025.

## Incremental build

Rustbolt v1.1 introduces experimental support for [incremental build](/config/experiments#experimentsincremental), which significantly enhances Rustbolt's HMR performance.

We will continue to optimize this feature in future versions until it is enabled by default.

## Persistent cache

Persistent cache can cache the build artifacts during multiple builds, significantly reducing the time for subsequent builds, especially providing a substantial performance boost for large projects.

Rustbolt v1.2 introduces experimental support for [persistent cache](/config/experiments#experimentscache). We will continue to optimize it in the future to further improve cache performance and coverage.

## Portable cache

The evolution path of Rustbolt's caching capabilities follows a sequential implementation of memory cache, persistent cache, and portable cache. Currently, Rustbolt has implemented the memory cache and is implementing the persistent cache.

After that, we plan to continue implementing portable cache. This means that Rustbolt's build cache will not only be persistent, but also portable across environments and machines. This will help teams make better use of the cache and lay the groundwork for distributed builds.

## Webpack API alignment

As webpack has a rich API interface, we are taking a progressive approach to support them. We will closely follow community feedback and prioritize support for commonly used loaders and plugins.

## Stabilize Rust API

Currently, higher-level tools can use the [JS API](/api/javascript-api/index) to integrate Rustbolt, which provides good extensibility. However, the communication overhead between Rust and JavaScript that limits the performance of Rustbolt. We also provide the [SWC Wasm plugin](/guide/features/builtin-swc-loader#jscexperimentalplugins) to support extensions, but its performance is still slower than native languages.To provide higher-level tools with more flexible integration options and better performance, we plan to expose Rustbolt's Rust API for integration.

## Improved ESM output

ESM is the standard for JavaScript modules. We are currently improving Rustbolt and webpack's support for ESM output and creating a library build tool based on Rustbolt called [Rslib](https://github.com/khulnasoft/rslib). This will allow developers to make better use of ESM's static analysis and tree-shaking when building npm packages.

## React Server Components support

At ByteDance, we have experimentally supported RSC ([React Server Components](https://react.dev/reference/rsc/server-components)) based on Rustbolt and validated it in a large web application. In the future, Rustbolt will provide first-class support for RSC, with more core features to make RSC easier to implement. For example, Rustbolt now supports the [layer](/config/experiments#experimentslayers) feature, which allows to build for multiple environments in a single run.

## TypeScript-based optimization

Currently, when Rustbolt processes TypeScript modules, it first converts them to JavaScript through a loader before further processing. This provides flexibility but also hinders further optimization of the build output. For example, developers need to use `enum` instead of `const enum`, but `enum` is difficult to optimize as a constant. In the future, we plan to treat TypeScript as a first-class citizen in Rustbolt, leveraging TypeScript's static information to provide more advanced compile-time optimization of the build output (such as [type-based property renaming](https://github.com/google/closure-compiler/wiki/Type-Based-Property-Renaming)).

## Continuously improving performance

Performance is the core selling point and focus of Rustbolt development. In the future we'll explore higher-performance concurrent/multi-core-friendly algorithms, higher-performance caching solutions, higher-performance plugin communication solutions, etc.

## Expanding the test suite

Today Rustbolt is primarily tested using a subset of webpack's test cases. In the future, we'll cover more of these tests, while also expanding the test suite and including community projects to ensure compatibility across Rustbolt releases.

## Collaboration with community partners

We are very willing to provide support to framework teams and toolchains within the community to unleash the true performance advantages of Rustbolt. If your framework or toolchain has a demand for high-performance build engines, let us know!
